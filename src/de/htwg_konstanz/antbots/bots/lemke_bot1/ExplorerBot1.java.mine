package de.htwg_konstanz.antbots.bots.lemke_bot1;

import java.awt.Color;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import de.htwg_konstanz.antbots.common_java_package.Aim;
import de.htwg_konstanz.antbots.common_java_package.Ant;
import de.htwg_konstanz.antbots.common_java_package.Bot;
import de.htwg_konstanz.antbots.common_java_package.GameInformations;
import de.htwg_konstanz.antbots.common_java_package.Ilk;
import de.htwg_konstanz.antbots.common_java_package.Logger;
import de.htwg_konstanz.antbots.common_java_package.Tile;
import de.htwg_konstanz.antbots.common_java_package.helper.Pathfinding;
import de.htwg_konstanz.antbots.visualizer.ExplorationVisualizer;
import de.htwg_konstanz.antbots.visualizer.OverlayDrawer;
import de.htwg_konstanz.antbots.visualizer.OverlayDrawer.SubTile;

public class ExplorerBot1 extends Bot {

	private Logger logger = new Logger("log.txt");
	private GameInformations gameI;

	private int turn = 0;
	private Pathfinding pathfinding;

	public static void main(String[] args) throws IOException {
		new ExplorerBot1().readSystemInput();
	}

	private void init() {
		gameI = gameStateInforamtions();
		pathfinding = new Pathfinding(logger, gameI);
	}

	@Override
	public void doTurn() {
		if (turn == 0) {
			init();
		}

		//
		ExplorationVisualizer.visualizeNewStep(gameI);

		hybrid();
		// exploration();
		// collect();

	}

	/**
	 * Every foot is a destiny of the next ant. THe other ants do exploration.
	 */
	private void hybrid() {
		int radius = (int) Math.sqrt(gameI.getViewRadius2());

		Set<Tile> antsGoingForFoot = new HashSet<Tile>();

		Set<Tile> foodTiles = gameI.getFoodTiles();
		Set<Ant> myAnts = gameI.getMyAnts();
		
		// next ant to foot
		for (Tile foot : foodTiles) {
			// get the next ant
			int distance = Integer.MAX_VALUE;
			List<Tile> theNextPath = null;
			for (Ant ant : myAnts) {
				
				Tile antPosition = ant.getAntPosition();
				// ignore ants with footjob
				if (antsGoingForFoot.contains(ant))
					continue;
				
				// visitables
				Set<Tile> visitable = gameI.getVisitableTilesInRadius(foot,
						radius);
				
				// ant is too far away
				if(!visitable.contains(ant))
					continue;
				
				// djkstra
				List<Tile> trypath = pathfinding.searchShortestPath(antPosition, foot, visitable);
				// find nearest
				if (trypath!= null && trypath.size() < distance) {
					distance = trypath.size();
					theNextPath = trypath;
				}

			}

			if (theNextPath != null && theNextPath.size() >= 1) {
				// get the foot!!!
				Tile ant = theNextPath.get(0);
				antsGoingForFoot.add(ant);
				
				// draw arror
				OverlayDrawer.drawArrow(ant, theNextPath.get(theNextPath.size()-1));
				
				List<Aim> aim = gameI.getDirections(ant, theNextPath.get(1));
				if (!aim.isEmpty())
					gameI.issueOrder(ant, aim.get(0));
			}
		}
		
		// other ants go explore
		for (Ant ant : myAnts) {
			Tile antPosition = ant.getAntPosition();
			if(!antsGoingForFoot.contains(antPosition)){
				exploration(antPosition);
			}
		}

	}

	/**
	 * the ant runs to their next food
	 */
	private void collect() {
		if (turn == 0) {
			gameI = gameStateInforamtions();
			pathfinding = new Pathfinding(logger, gameI);
		}
		turn++;

		for (Ant ant : gameI.getMyAnts()) {

			
			Tile antsTile = ant.getAntPosition();

			// which tiles can be rached
			int maxSteps = (int) Math.sqrt(gameI.getViewRadius2());
			Set<Tile> visitable = pathfinding.visitableInXSteps(antsTile,
					gameI.getMap(), maxSteps);

			for (Tile a : visitable) {
				OverlayDrawer.drawTileSubtile(a.getRow(), a.getCol(),
						OverlayDrawer.SubTile.BM);
			}

			// get the food tiles
			Set<Tile> visitableFood = new HashSet<Tile>();
			for (Tile tile : visitable) {
				if (gameI.getIlk(tile) == Ilk.FOOD)
					visitableFood.add(tile);
			}

			// find the next food
			List<Tile> nextFoodRoute = null;
			for (Tile food : visitableFood) {
				List<Tile> tmp = pathfinding.searchShortestPath(antsTile, food,
						visitable);

				if (nextFoodRoute == null
						|| (tmp.size() > 1 && nextFoodRoute.size() > tmp.size())) {
					nextFoodRoute = tmp;
				}
			}

			if (nextFoodRoute != null && !nextFoodRoute.isEmpty()) {
				// get food!
				for (Tile a : nextFoodRoute) {
					OverlayDrawer.setFillColor(Color.YELLOW);
					OverlayDrawer.drawTileSubtile(a.getRow(), a.getCol(),
							SubTile.MM);
				}

				if (nextFoodRoute != null && nextFoodRoute.size() > 1) {
					List<Aim> aim = gameI.getDirections(antsTile,
							nextFoodRoute.get(1));
					if (!aim.isEmpty())
						gameI.issueOrder(antsTile, aim.get(0));
				}

			} else {
				// explore
				exploration(antsTile);
			}
		}
	}

	/**
	 * Send all ants to exploration.
	 */
	private void exploration() {

		// Fï¿½r jede Ameise
		for (Ant ant : gameI.getMyAnts()) {
			Tile antsTile = ant.getAntPosition();
			exploration(antsTile);
		}
	}

	/**
	 * Send one ant to exploration.
	 */
	private void exploration(Tile antsTile) {

		// which tiles can be rached
		int radius = (int) Math.sqrt(gameI.getViewRadius2()) + 1;
		// Set<Tile> visitable = pathfinding.visitableInXSteps(antsTile,
		// gameI.getMap(), radius);

		// f
		Set<Tile> visitable = gameI.getVisitableTilesInRadius(antsTile, radius);

		for (Tile tile : visitable) {
			OverlayDrawer.setFillColor(Color.GRAY);
			OverlayDrawer.drawTileSubtile(tile.getRow(), tile.getCol(),
					OverlayDrawer.SubTile.BM);
		}

		// get the tile with die highest exploreValue
		Tile target = gameI.getMaxVisibilityAgo(visitable).iterator().next();

		// get the route to the target
		List<Tile> route = pathfinding.searchShortestPath(antsTile, target,
				visitable);

		// the highest destination could be behind water.
		while (route == null) {
			OverlayDrawer.setFillColor(Color.RED);
			OverlayDrawer.drawTile(antsTile);
			// target is not rachable -> remove it form visitable
			visitable.remove(target);
			// get max
			target = gameI.getMaxVisibilityAgo(visitable).iterator().next();
			// try route
			pathfinding = new Pathfinding(logger, gameStateInforamtions());

			// checks TODO whyy??
			visitable.add(antsTile);

			route = pathfinding.searchShortestPath(antsTile, target, visitable);
		}

		for (Tile ter : route) {
			OverlayDrawer.setFillColor(Color.RED);
			OverlayDrawer.drawTileSubtile(ter.getRow(), ter.getCol(),
					SubTile.MM);
		}

		//
		if (route != null && route.size() > 0) {
			List<Aim> aim = gameI.getDirections(antsTile, route.get(1));
			if (!aim.isEmpty())
				gameI.issueOrder(antsTile, aim.get(0));
		}
	}

}
